import { posix } from 'path';
import * as vscode from 'vscode';

type AssetsFolder = 'images' | 'svgs';

// èµ„æºç¼“å­˜å¯¹è±¡
const assets: Record<AssetsFolder, Record<string, string>> = { images: {}, svgs: {} };
// dart codeç¼“å­˜å¯¹è±¡
const dartCodeCache: Record<AssetsFolder, string> = { images: '', svgs: '' };

// debounce
const debounce = (fn: any, delay: number) => {
	let timer: NodeJS.Timeout;
	return (...args: any[]) => {
		clearTimeout(timer);
		timer = setTimeout(() => {
			fn(...args);
		}, delay);
	};
};

// å¤„ç†fileæ ¼å¼, è¿”å›ç¬¦åˆè¦æ±‚çš„æ–‡ä»¶åå’Œæ–‡ä»¶æ ¼å¼
const handleFile = (file: vscode.Uri): { fileNameCamel?: string; fileFormatCamel?: string } => {
	// è·å–å½“å‰æ–‡ä»¶æ‰€å±çš„æ˜¯assetsæ–‡ä»¶å¤¹ä¸‹å“ªä¸ªæ–‡ä»¶å¤¹
	// const assetsFolder = file.path.indexOf() as AssetsFolder;
	// ä»pathä¸­è·å–æ–‡ä»¶å, æ’é™¤æ ¼å¼
	const fileName = file.path.split('/').pop()?.split('.').shift();
	// ä»æ–‡ä»¶åä¸­è·å–æ ¼å¼
	const fileFormatCamel = file.path
		.split('/')
		.pop()
		?.split('.')
		.pop()
		?.replace(/^\S/, (s) => s.toUpperCase());
	// åˆ¤æ–­nameæ˜¯å¦æ˜¯ä¸‹åˆ’çº¿å‘½åæˆ–è€…-å‘½å, å¦‚æœæ˜¯_æˆ–è€…-å‘½å, å°±è½¬æ¢æˆé©¼å³°å‘½å, å¦‚æœå­˜åœ¨ç©ºæ ¼, å°±å»æ‰ç©ºæ ¼, å¦‚æœé¦–å­—æ¯æ˜¯å¤§å†™å°±è½¬æ¢æˆå°å†™
	const fileNameCamel = fileName
		?.replace(/\s/g, '')
		.replace(/^\S/, (s) => s.toLowerCase())
		.replace(/[_-]\S/g, (s) => {
			// åˆ¤æ–­sæ˜¯å¦æ˜¯æ•°å­—, å¦‚æœæ˜¯æ•°å­—(åŒ…æ‹¬0)ä¸ç”¨è½¬æ¢
			if (Number(s[1]) || s[1] === '0') {
				return s;
			}
			return s.slice(1).toUpperCase();
		});
	return {
		fileNameCamel,
		fileFormatCamel
	};
};

// å¤„ç†ç¼“å­˜å¯¹è±¡çš„æ•°æ®ç»“æ„, æä¾›fileå¯¹è±¡å’Œç¼“å­˜å¯¹è±¡å¼•ç”¨ä¸ºå‚æ•°, è¿”å›ç¼“å­˜å¯¹è±¡å¼•ç”¨
type CacheHandler = (file: vscode.Uri, cache: Record<string, string>) => Record<string, string>;
const cacheHandler: CacheHandler = (file, cache) => {
	const { fileNameCamel, fileFormatCamel } = handleFile(file);
	// æŠŠkey valueå¯¹æ·»åŠ åˆ°å¯¹è±¡ä¸­
	cache[`${fileNameCamel}${fileFormatCamel}`] = file.path.substring(file.path.indexOf('assets'));
	return cache;
};

// å°†ç¼“å­˜å¯¹è±¡è½¬æ¢ä¸ºdart code
const cacheToDartCode = async (
	cache: Record<string, string>,
	className: AssetsFolder,
	options?: {
		// æ˜¯å¦éœ€è¦è¦†ç›–assets.dartæ–‡ä»¶
		cover?: boolean;
		// æ˜¯å¦æç¤ºæˆåŠŸ
		tip?: boolean;
	}
): Promise<void> => {
	// å°†cacheæŒ‰ç…§keyæ’åº
	const sortedCache = Object.keys(cache)
		.sort()
		.reduce((acc, key) => {
			acc[key] = cache[key];
			return acc;
		}, {} as Record<string, string>);
	const val = Object.entries(sortedCache)
		.map(([key, value]) => `  static const ${key} = '${value}';`)
		.join('\n');
	const dartCode = `class Assets${className?.replace(/^\S/, (s) => s.toUpperCase())} {\n${val}\n}`;
	// å°†codeç¼“å­˜åˆ°dartCodeCacheä¸­
	dartCodeCache[className] = dartCode;
	// å¦‚æœéœ€è¦è¦†ç›–åŸæœ‰çš„assets.dartæ–‡ä»¶, å°±å†™å…¥æ–‡ä»¶
	if (options?.cover) {
		// å¾ªç¯ç¼“å­˜çš„dart code
		let code = '// code generated by [generate-resource-dart-code] vscode-extension.\n';
		Object.entries(dartCodeCache).forEach(([key, value]) => {
			code += value + '\n\n';
		});
		const folderUri = vscode.workspace.workspaceFolders![0].uri;
		const fileUri = folderUri.with({ path: posix.join(folderUri.path, 'lib', 'assets.dart') });
		await vscode.workspace.fs.writeFile(fileUri, Buffer.from(code));
		// å¦‚æœä¸æç¤ºæˆåŠŸ, å°±ä¸æç¤º
		if (options?.tip) {
			vscode.window.showInformationMessage(
				`[generate-resource-dart-code] ${className}å†…å®¹å·²æˆåŠŸç”ŸæˆğŸ‰`
			);
		}
	}
};

// éå†å¯¹åº”èµ„æºæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶, å¹¶ä¸”å°†æ–‡ä»¶åå’Œæ–‡ä»¶è·¯å¾„æ·»åŠ åˆ°ç¼“å­˜å¯¹è±¡ä¸­
const traverseAssetsFolder = async (
	key: AssetsFolder,
	options?: { clear?: boolean }
): Promise<void> => {
	// å¦‚æœclearä¸ºtrue, å°±æ¸…ç©ºç¼“å­˜å¯¹è±¡
	if (options?.clear) {
		assets[key] = {};
	}
	// éå†å¯¹åº”èµ„æºæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
	const files = await vscode.workspace.findFiles(`assets/${key}/**`);
	// åˆå§‹åŒ–ç¼“å­˜å¯¹è±¡
	files.forEach((file) => {
		cacheHandler(file, assets[key as AssetsFolder]);
	});
};

// è¿­ä»£èµ„æºæ–‡ä»¶å¤¹, åˆå§‹åŒ–ç¼“å­˜å¯¹è±¡çš„å°è£…æ–¹æ³•
const init = async (clear: boolean, cb?: (key: AssetsFolder) => void): Promise<void> => {
	for (let key in assets) {
		await traverseAssetsFolder(key as AssetsFolder, { clear });
		cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true, tip: true });
		cb && cb(key as AssetsFolder);
	}
};

export async function activate(context: vscode.ExtensionContext) {
	// è·å–å½“å‰é¡¹ç›®çš„æ ¹ç›®å½•ç¬¬ä¸€çº§æ–‡ä»¶
	const isFlutter = await vscode.workspace.findFiles('pubspec.yaml');
	if (isFlutter.length === 0) {
		// å¦‚æœä¸å­˜åœ¨pubspec.yamlæ–‡ä»¶ï¼Œç›´æ¥è¿”å›
		return;
	}
	// æ³¨å†Œå‘½ä»¤
	const disposable = vscode.commands.registerCommand(
		'extension.generateResourceDartCode',
		async () => {
			init(true);
		}
	);
	context.subscriptions.push(disposable);

	init(false, async (key) => {
		let watcher = vscode.workspace.createFileSystemWatcher(`**/assets/${key}/**`);
		watcher.onDidCreate(async (uri: vscode.Uri) => {
			// åˆ›å»º/ä¿®æ”¹æ–‡ä»¶éƒ½ä¼šè§¦å‘è¿™ä¸ªäº‹ä»¶, ä½†æ˜¯å›è°ƒå¹¶æ²¡æœ‰æä¾›old, newçš„uri (è‡ªå·±ä¸èƒ½æ ¹æ®ç¼“å­˜å¯¹è±¡diff), æ‰€ä»¥åªèƒ½é‡æ–°éå†æ–‡ä»¶å¤¹ç”Ÿæˆç¼“å­˜å¯¹è±¡
			await traverseAssetsFolder(key as AssetsFolder, { clear: true });
			debounce(
				cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true }),
				500
			);
		});
		watcher.onDidDelete(async (uri: vscode.Uri) => {
			const { fileNameCamel, fileFormatCamel } = handleFile(uri);
			if (assets[key as AssetsFolder][`${fileNameCamel}${fileFormatCamel}`]) {
				delete assets[key as AssetsFolder][`${fileNameCamel}${fileFormatCamel}`];
			}
			debounce(
				cacheToDartCode(assets[key as AssetsFolder], key as AssetsFolder, { cover: true }),
				500
			);
		});
	});
}
